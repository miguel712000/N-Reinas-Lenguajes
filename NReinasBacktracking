#lang racket

(define backtrackingNReinas
  (lambda(n cont)
    (cond ((or(>= 3 n) (< cont 1)) '())
          (else(reinasAux '(0) n n cont)))))

(define reinasAux
  (lambda (lista n limite cont)
    (cond ((equal? cont 0) '())
          ((equal? (car lista) limite)
           (cond((equal? n limite) '())
                 (else (reinasAux (cons (+ 1 (cadr lista)) (cddr lista)) (+ n 1) limite cont))))
          ((valido? lista n)
           (cond ((equal? n 1) (append (list lista) (reinasAux (cons (+ 1 (car lista)) (cdr lista)) n limite (- cont 1))))
                 (else (reinasAux (cons 0 lista) (- n 1) limite cont))))
          (else (reinasAux (cons (+ 1 (car lista)) (cdr lista)) n limite cont)))))

(define valido? 
  (lambda (lista n)
    (cond ((or (ormap (lambda (x) (= x (car lista))) (cdr lista)) (diagonal? lista (- (longitud lista) 1) 0)) #f)
          (else #t))))

(define diagonal?
  (lambda (lista n i)
    (cond ((= (longitud lista) 1) #f)
          ((= (abs(- (car (invert lista)) (car lista))) (abs(- i n))) #t)
          (else( diagonal? (invert(cdr(invert lista))) n (+ i 1))))))

(define invert
  (lambda (l)
    (cond ((null? l) l)
          (else (append (invert (cdr l)) (list (car l)))))))
  
(define longitud
  (lambda (l)
    (cond ((null? l) 0)
          (else (+ 1 (longitud (cdr l)))))))
